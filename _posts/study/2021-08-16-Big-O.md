---
layout: post
title: "Big-O 알고리즘"
subtitle: "Big-O 표기법"
date: 2021-08-16 01:58:51 +0900
categories: study
tags: algorithm
comments: true
published: true
---

- 목차
  - [1.정의](#1.정의)
  - [2.특징](#2.특징)
  - [3.종류](#3.종류)
  - [4.출처](#4.출처)

# Big-O

## 정의

- 알고리즘 성능을 수학적으로 표현해주는 표기법

## 특징

- 알고리즘의 `시간복잡도`와 `공간복잡도`를 표현할 수 있다
- 알고리즘의 실제 러닝타임을 표시하는 것이라기보다, `데이터나 사용자의 증가율에 따른 알고리즘의 성능을 예측하는 것이 목표`
  - 따라서, 상수와 같은 숫자들은 모두 1이 된다(`Drop constants`)

## 종류

### O(1)

`[오원 알고리즘]`

입력 데이터 크기에 상관없이, <span style="color:indianred">언제나 일정한 시간이 걸리는</span> 알고리즘

```javascript
F(int[] n) {
    return (n[0] == 0) ? true : false;
}
```

- 첫 번재 배열값이 0인지 확인한다
- 인자로 받는 배열값이 얼마나 큰지와 상관 없이, 언제나 일정한 속도로 결과를 반환한다
- 이런 경우, 이 알고리즘을 "O(1)의 시간복잡도를 가진다"고 표현한다
- 처리시간에 관계 없이 데이터의 크기가 일정하다. 즉, 성능의 변함이 없다

### O(N)

```javascript
F(int[] n) {
    for(int[] n){
        for i = 0 to n.length
            print i
    }
}
```

- 입력 데이터의 크기에 비례해서 처리 시간이 걸리는 알고리즘
- 이 함수는 n개의 데이터를 받으면, n번 loop를 도니까, n이 하나 늘어날 때마다,
- 처리가 한 번씩 늘어나서, n의 크기만큼 처리 시간이 걸린다
- 그래프를 보면, n이 증가함에 따라 비례해서 처시 시간도 같이 증가한다.

### O(N²)

```javascript
F(int[] n) {
    for(int[] n){
        for i = 0 to n.length
            for j = 0 to n.length
                print i + j;
    }
}
```

- n을 돌리면서, 그 안에서 n으로 loop를 또 돌릴 때, n square가 된다
- n개의 데이터를 받으면, 첫 번째 loop에서 n번 돌면서, 각각의 element에서 n번씩 또 도니까, 처리 횟수가 N²만큼 걸린다
- 따라서, n이 커질수록, 처리 시간도 커진다

- 그래프를 보면, 완만한 기울기에서, 급격한 기울기로 변화한다

### O(nm)

```javascript
F(int[] n, int[] m) {
       for i = 0 to n.length
           for j = 0 to m.length
               print i + j;
}
```

- O(N²)와 비슷하지만, n을 두 번 돌리는 게 아니라, m을 n만큼 돌린다
- n은 엄청 크고, m은 작을 수도 있기 때문에 변수가 다르다면, BIG-O 표기법도 다르게 표기해야 한다
- nm도 그래프가 증가할수록 수직에 가까운 모양이 된다

### O(N³)

- N²에 N을 한 번 더 돌리면, N³이 된다
- O(N³)은 O(N²)과 비슷한 양상을 보이지만, 가로&세로&높이까지 더해지니까 더 급격하게 처리시간이 늘어난다

### O(2ⁿ)

- 피보나치 수열: O(2ⁿ)의 대표적인 알고리즘
- 매번 함수가 호출될 때마다, 두 번씩 또 호출한다
- 그것을 트리의 높이만큼 반복한다
- 그래프를 보면, O(N³)보다도 그래프의 증가에 따라 처리 시간이 현저하게 늘어난다

### O(log n)

- `이진 검색` : O(log n)의 대표적인 알고리즘
- `오름차순`으로 정렬된 배열안에서 key값(key===6)을 찾는다고 자정하자
- 정렬이 되어있으니까, 이진 검색을 하려면 우선 가운데 값을 찾아서 key값과 비교한다
- key값이 더 크니까 오른쪽에 있다는 뜻이다
- 그러면 앞쪽 데이터는 제외시킨다
- 뒷쪽 데이터들로 다시 중간값을 찾아서 key값과 비교한다
- key값이 더 작으니까 왼쪽에 있다는 뜻이다
- 그러면 뒷쪽 데이터는 제외시킨다
- 앞쪽을 보니 6밖에 안 남았다
- `O(log n) 알고리즘`
- `한번 처리가 진행될 때마다 검색해야 하는 데이터의 양이 절반씩 줄어드는 알고리즘`
- 이진 검색 알고리즘을 구현하면 다음과 같다

```javascript
F(k, arr, s, e){ // 시작 부분(s === 0), 끝 지점(e === arr.length - 1)
   if(s > e) return -1;
   m = ( s + e ) / 2; // 주어진 범위의 중간값을 찾는다
   if(arr[m] == k) return m;
   else if(arr[m] > k) return F(k, arr, s, m - 1); // 찾는값이 중간값보다 작으면 중간지점 바로 이전값까지로 범위를 조정해서 다시 호출한다
   else return F(k, arr, m+1, e) // 키값이 중간값보다 큰 경우에는 중간지점 다음 방부터 맨 끝까지 호출한다
}
```

- 이렇게 호출하면 한 번 함수가 호출될 때마다, 한번 함수가 호출될 때마다 중간값을 기준으로 절반은 검색 영역에서 제외시키기 때문에 '순차 검색'에 비해 속도가 현저하게 빠르다

- 그래프를 보면, 데이터가 증가해도, 처리 성능이 크게 차이나지 않는다

### O(sqrt(n))

- 주어진 값의 제곱근을 나타내는 Big-O 표기법이다

### Drop constants

- Big-O에서 상수는 과감히 버린다

- Case Study

```javascript
F(int[] n){
    for i = 0 to n.length
        print i
    for i = 0 to n.length
        print i
}
```

- 이 함수의 시간복잡도는 얼마일까
- n만큼씩 두 번 돌리기 때문에 '2n'만큼의 시간이 걸린다
- 그런데 Big-O 표기법에서는 `2n`은 그냥 `n`으로 표시한다
- Big-O 표기법은 알고리즘의 실제 러닝타임을 측정하기 위해 만들어진 것이 아니기 때문이다
- 장기적으로 데이터가 증가함에 따른 처리 시간의 증가율을 예측하기 위해 만들어진 표기법이다

![시간복잡도 그래프](/assets/img/bigo.PNG)

---

# 4. 출처

- [[Youtube]엔지니어대한민국](https://www.youtube.com/watch?v=6Iq5iMCVsXA)
