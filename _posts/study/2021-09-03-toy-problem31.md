---
layout: post
title: "[ToyProblem] 31_rangeMinimum"
subtitle: "(coming soon)"
date: 2021-09-03 09:00:00 +0900
categories: study
tags: algorithm
comments: true
published: false
---

# ê°œìš”

- ëª©ì°¨
  - [1.ë¬¸ì œâœ‰ï¸](#1.ë¬¸ì œ)
  - [2.ë ˆí¼ëŸ°ìŠ¤ì½”ë“œğŸ”–](#2.ë ˆí¼ëŸ°ìŠ¤ì½”ë“œ)
  - [3.í‚¤í¬ì¸íŠ¸ğŸ”](#3.í‚¤í¬ì¸íŠ¸ğŸ”‘)
  - [4.ì¶œì²˜ğŸ”](#4.ì¶œì²˜ğŸ”)

# 1. ë¬¸ì œ

ì •ìˆ˜ë¥¼ ìš”ì†Œë¡œ ê°–ëŠ” ë°°ì—´ê³¼ íŠ¹ì • êµ¬ê°„ì„ ì…ë ¥ë°›ì•„, í•´ë‹¹ êµ¬ê°„ ë‚´ì—ì„œ ìµœì†Œê°’ì„ ë¦¬í„´í•´ì•¼ í•©ë‹ˆë‹¤.

## ì…ë ¥

### ì¸ì 1 : arr

- `number` íƒ€ì…ì„ ìš”ì†Œë¡œ ê°–ëŠ” ë°°ì—´
- `arr.length`ëŠ” 500,000 ì´í•˜
- `arr[i]`ëŠ” -100,000 ì´ìƒ 100,000 ì´í•˜ì˜ ì •ìˆ˜

### ì¸ì 2 : ranges

- `number` íƒ€ì…ì„ ìš”ì†Œë¡œ ê°–ëŠ” ë°°ì—´
- `ranges.length`ëŠ” 10,000 ì´í•˜
- `ranges[i]`ëŠ” íŠ¹ì • êµ¬ê°„ì„ ì˜ë¯¸
- `ranges[i][0]`ì€ ië²ˆì§¸ êµ¬ê°„ì˜ ì‹œì‘ ì¸ë±ìŠ¤
- `ranges[i][1]`ì€ ië²ˆì§¸ êµ¬ê°„ì˜ ë§ˆì§€ë§‰ ì¸ë±ìŠ¤

## ì¶œë ¥

- ë°°ì—´(`arr`)ë¥¼ ë¦¬í„´í•´ì•¼ í•©ë‹ˆë‹¤. (ì…ì¶œë ¥ ì˜ˆì‹œ ì°¸ê³ )
- `arr[i]`ëŠ” ië²ˆì§¸ êµ¬ê°„(`ranges[i]`)ì˜ ìµœì†Œê°’

## ì…ì¶œë ¥ ì˜ˆì‹œ

```javascript
const arr = [1, 3, 2, 7, 9, 11];
const mins = rangeMinimum(arr, [
  [1, 4],
  [0, 3],
]);
console.log(mins); // --> [2, 1]
```

## Advanced

- Advanced1: ì£¼ì–´ì§„ ë°°ì—´ì—ì„œ íŠ¹ì • êµ¬ê°„ì˜ ìµœì†Œê°’ì„ êµ¬í•˜ëŠ” ë‹¨ìˆœí•œ ì•Œê³ ë¦¬ì¦˜ì€ ë‹¨ìˆœ ìˆœíšŒ(`O(N)`)ì…ë‹ˆë‹¤. ê°™ì€ ë°°ì—´ì— ëŒ€í•´ì„œ ë‹¤ì–‘í•œ êµ¬ê°„ì— ëŒ€í•œ ìµœì†Œê°’ì„ êµ¬í•  ê²½ìš°, ë‹¨ìˆœ ìˆœíšŒëŠ” `O(N^2)` ì…ë‹ˆë‹¤(êµ¬ê°„ì˜ ê°œìˆ˜ë„ Nê°œë¼ ê°€ì •í•  ê²½ìš°). ì ì ˆí•œ ìë£Œêµ¬ì¡°ë¥¼ í†µí•´ ì´ì™€ ê°™ì€ êµ¬ê°„ ì¡°íšŒì— ëŒ€í•œ ë°˜ë³µ ì‘ì—…ì„ íš¨ìœ¨ì (`O(N \* logN)`)ìœ¼ë¡œ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. êµ¬ê°„ íŠ¸ë¦¬(segment tree)ì— ëŒ€í•´ì„œ í•™ìŠµí•˜ì‹œê³ , Advanced í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë¥¼ í†µê³¼í•´ ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤.
- íŠ¸ë¦¬ë¥¼ ê°ì²´ ë˜ëŠ” ë°°ì—´ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê°ì²´ë¡œ êµ¬í˜„í•˜ëŠ” ê²ƒì´ ë³´ë‹¤ ì§ê´€ì ì´ê¸° ë•Œë¬¸ì— ê°ì²´ë¡œ ë¨¼ì € ë„ì „í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤. ë ˆí¼ëŸ°ìŠ¤ëŠ” ëª¨ë‘ ì£¼ì–´ì§‘ë‹ˆë‹¤.
- êµ¬ê°„ì˜ ìµœëŒ€ê°’, í•©ë„ ë™ì¼í•œ ë¡œì§ìœ¼ë¡œ êµ¬í˜„í•˜ë©´ ë©ë‹ˆë‹¤.

---

# 2. ë ˆí¼ëŸ°ìŠ¤ ì½”ë“œ

## ì´ˆê¸°í™”

```javascript
const rangeMinimum = function (arr, ranges) {
  // TODO: ì—¬ê¸°ì— ì½”ë“œë¥¼ ì‘ì„±í•©ë‹ˆë‹¤.
};
```

## ë ˆí¼ëŸ°ìŠ¤

```javascript
// naive solution: O(N) (search only)
// const rangeMinimum = function (arr, ranges) {
//   return ranges.map((range) => {
//     const [start, end] = range;
//     let min = Number.MAX_SAFE_INTEGER;
//     for (let i = start; i <= end; i++) {
//       if (arr[i] < min) min = arr[i];
//    }
//     return min;
//   });
// };

// solution with segment tree: O(logN) (search only)
// object implementaion
const rangeMinimum = function (arr, ranges) {
  // ts: tree start. te: tree end
  // arrì˜ tsë¶€í„° teê¹Œì§€ë¥¼ treeë¡œ ë§Œë“ ë‹¤.
  const createMinTree = (arr, ts, te) => {
    // base case
    if (ts === te) {
      return { value: arr[ts] };
    }

    // recursive case
    // í˜„ì¬ ë²”ìœ„ë¥¼ ì ˆë°˜ì„ ê¸°ì¤€ìœ¼ë¡œ ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë‚˜ëˆˆë‹¤
    const mid = parseInt((ts + te) / 2);
    const left = createMinTree(arr, ts, mid);
    const right = createMinTree(arr, mid + 1, te);

    return {
      value: Math.min(left.value, right.value),
      left,
      right,
    };
  };
  const tree = createMinTree(arr, 0, arr.length - 1);

  // rs: range start, re: reange end
  const findMin = (ts, te, rs, re, tree) => {
    // í˜„ì¬ treeì™€ êµ¬ê°„ì´ ì •í™•íˆ ì¼ì¹˜í•˜ê±°ë‚˜
    // êµ¬ê°„ì´ treeë¥¼ í¬í•¨í•  ê²½ìš°
    if (rs <= ts && te <= re) {
      return tree.value;
    }

    // í˜„ì¬ treeì— ì£¼ì–´ì§„ êµ¬ê°„ì´ ê²¹ì¹˜ì§€ ì•ŠëŠ” ê²½ìš°
    if (te < rs || re < ts) {
      return Number.MAX_SAFE_INTEGER;
    }

    // ê²¹ì¹˜ëŠ” ë¶€ë¶„ì´ ì¡´ì¬í•˜ëŠ” ê²½ìš°
    const mid = parseInt((ts + te) / 2);
    return Math.min(
      findMin(ts, mid, rs, re, tree.left), //
      findMin(mid + 1, te, rs, re, tree.right)
    );
  };

  const mins = ranges.map((range) => {
    const [start, end] = range;
    return findMin(0, arr.length - 1, start, end, tree);
  });
  return mins;
};

// solution with segment tree: O(logN) (search only)
// array implementaion
// const rangeMinimum = function (arr, ranges) {
//   const createMinTree = (arr, ts, te, tree, idx) => {
//     if (ts === te) {
//       tree[idx] = arr[ts];
//       return arr[ts];
//     }

//     const mid = Math.floor((ts + te) / 2);
//     tree[idx] = Math.min(
//       createMinTree(arr, ts, mid, tree, idx * 2 + 1), //
//       createMinTree(arr, mid + 1, te, tree, idx * 2 + 2)
//     );

//     return tree[idx];
//   };

//   // íŠ¸ë¦¬ ì „ì²´ì˜ ë†’ì´(ë£¨íŠ¸ ë…¸íŠ¸ì—ì„œ ê°€ì¥ ê¹Šì€ ë¦¬í”„ ë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬)ë¥¼ êµ¬í•˜ê³ 
//   // ì „ì²´ ë°°ì—´ì˜ í¬ê¸°ë¥¼ êµ¬í•œë‹¤.
//   const height = Math.ceil(Math.log2(arr.length));
//   const size = Math.pow(2, height + 1) - 1;
//   const tree = Array(size).fill(null);
//   createMinTree(arr, 0, arr.length - 1, tree, 0);

//   const findMin = (ts, te, rs, re, idx) => {
//     if (rs <= ts && te <= re) {
//       return tree[idx];
//     }

//     if (te < rs || re < ts) {
//       return Number.MAX_SAFE_INTEGER;
//     }

//     const mid = parseInt((ts + te) / 2);
//     return Math.min(
//       findMin(ts, mid, rs, re, 2 * idx + 1), //
//       findMin(mid + 1, te, rs, re, 2 * idx + 2)
//     );
//   };

//   const mins = ranges.map((range) => {
//     const [start, end] = range;
//     return findMin(0, arr.length - 1, start, end, 0);
//   });
//   return mins;
// };
```

---

# 3. í‚¤í¬ì¸íŠ¸

---

# 4. ì¶œì²˜
