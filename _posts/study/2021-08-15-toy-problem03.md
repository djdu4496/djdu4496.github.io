---
layout: post
title: "[ToyProblem] 03_isSubsetOf"
subtitle: "O(log N) μ•κ³ λ¦¬μ¦"
date: 2021-08-15 22:58:51 +0900
categories: study
tags: algorithm
comments: true
published: false
---

# κ°μ”

- λ©μ°¨
  - [1.λ¬Έμ β‰οΈ](#1.λ¬Έμ )
  - [2.λ νΌλ°μ¤μ½”λ“π”–](#2.λ νΌλ°μ¤μ½”λ“)
  - [3.ν‚¤ν¬μΈνΈπ”](#3.ν‚¤ν¬μΈνΈπ”‘)

# 1. λ¬Έμ 

λ‘ κ°μ λ°°μ—΄(`base`, `sample`)μ„ μ…λ ¥λ°›μ•„ `sample`μ΄ `base`μ λ¶€λ¶„μ§‘ν•©μΈμ§€ μ—¬λ¶€λ¥Ό λ¦¬ν„΄ν•΄μ•Ό ν•©λ‹λ‹¤.

## μ…λ ¥

### μΈμ 1 : base

- number νƒ€μ…μ„ μ”μ†λ΅ κ°–λ” μ„μμ λ°°μ—΄
- base.lengthλ” 100 μ΄ν•

### μΈμ 2 : sample

- number νƒ€μ…μ„ μ”μ†λ΅ κ°–λ” μ„μμ λ°°μ—΄
- sample.lengthλ” 100 μ΄ν•

## μ¶λ ¥

- boolean νƒ€μ…μ„ λ¦¬ν„΄ν•΄μ•Ό ν•©λ‹λ‹¤.

## μ£Όμμ‚¬ν•­

- `base`, `sample` λ‚΄μ— μ¤‘λ³µλλ” μ”μ†λ” μ—†λ‹¤κ³  κ°€μ •ν•©λ‹λ‹¤.

## μ…μ¶λ ¥ μμ‹

```javascript
let base = [1, 2, 3, 4, 5];
let sample = [1, 3];
let output = isSubsetOf(base, sample);
console.log(output); // --> true

sample = [6, 7];
output = isSubsetOf(base, sample);
console.log(output); // --> false

base = [10, 99, 123, 7];
sample = [11, 100, 99, 123];
output = isSubsetOf(base, sample);
console.log(output); // --> false
```

## Advanced

- μ‹κ°„ λ³µμ΅λ„λ¥Ό κ°μ„ ν•μ—¬, Advanced ν…μ¤νΈ μΌ€μ΄μ¤(`base`, `sample`μ κΈΈμ΄κ°€ 70,000 μ΄μƒ)λ¥Ό ν†µκ³Όν•΄ λ³΄μ„Έμ”.

---

# 2. λ νΌλ°μ¤ μ½”λ“

```javascript
const isSubsetOf = function (base, sample) {
  // naive solution: O(M * N)
  // return sample.every((item) => base.includes(item));

  // κ° λ°°μ—΄μ„ μ •λ ¬: O(N * logN), O(M * logM)
  // N >= M μ΄λ―€λ΅, O(N * logN)
  base.sort((a, b) => a - b);
  sample.sort((a, b) => a - b);
  // O(log N) μ•κ³ λ¦¬μ¦μ„ μ‹¤ν–‰ν•  ν•¨μ κµ¬ν„
  const findItemInSortedArr = (item, arr, from) => {
    for (let i = from; i < arr.length; i++) {
      // keyκ°’μ„ μ°ΎμΌλ©΄ ν•΄λ‹Ή indexλ¥Ό λ°ν™
      if (item === arr[i]) return i;
      // keyκ°’μ΄ λ°°μ—΄μ iλ²μ§Έ elementλ³΄λ‹¤ μ‘λ‹¤λ©΄, -1μ„ λ°ν™
      else if (item < arr[i]) return -1;
    }
    return -1;
  };

  let baseIdx = 0;
  for (let i = 0; i < sample.length; i++) {
    baseIdx = findItemInSortedArr(sample[i], base, baseIdx);
    // sample[i]μ¤‘ ν•λ‚λΌλ„ baseμ—μ„ λ°κ²¬λμ§€ μ•λ”λ‹¤λ©΄ false λ°ν™
    if (baseIdx === -1) return false;
  }
  // λ¨λ‘ λ°κ²¬λλ‹¤λ©΄ λ¶€λ¶„μ§‘ν•©μ΄λ―€λ΅ true λ°ν™
  return true;
};
```

---

# 3. ν‚¤ν¬μΈνΈ

1. naive solution

```javascript
const isSubsetOf = function (base, sample) {
  return sample.every((item) => base.includes(item));
};
```

2. forEach vs every λ©”μ†λ“

- forEach
  - μ£Όμ–΄μ§„ ν•¨μλ¥Ό λ°°μ—΄ μ”μ† κ°κ°μ— λ€ν•΄ μ‹¤ν–‰ν•©λ‹λ‹¤
- every
  - λ°°μ—΄ μ•μ λ¨λ“  μ”μ†κ°€ μ£Όμ–΄μ§„ νλ³„ ν•¨μλ¥Ό ν†µκ³Όν•λ”μ§€ ν…μ¤νΈν•μ—¬ Boolean κ°’μ„ λ°ν™ν•©λ‹λ‹¤

3. Does sort mutate?

- Yeah

```javascript
base.sort((a, b) => a - b); // μ›λ³Έ μ†μƒ
sample.sort((a, b) => a - b); // μ›λ³Έ μ†μƒ
```

4. O(log N) μ•κ³ λ¦¬μ¦

- N >= M μ΄λ―€λ΅, O(N \* logN)μ„ μ‚¬μ©ν•λ‹¤
- μ²λ¦¬ μ‹κ°„μ„ naive solutionλ³΄λ‹¤ ν„μ €ν μ¤„μΌ μ μλ‹¤

---
